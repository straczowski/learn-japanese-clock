# Architecture: Time Data Structure

## Core Concept: 4-Digit Time ID

Every time is represented as a **4-digit ID** in HHMM format:
- `"0830"` = 8:30 (8 hours, 30 minutes)
- `"1300"` = 13:00 (1:00 PM)
- `"2330"` = 23:30 (11:30 PM)
- `"0000"` = 0:00 (midnight)

## Time Generation Rules

**Difficulty: Easy (HOURS_ONLY)**
- Hours: 0-23 (any hour)
- Minutes: 0 only
- Examples: `"0800"`, `"1300"`

**Difficulty: Mid (HOURS_AND_HALF)**
- Hours: 0-23 (any hour)
- Minutes: 0 or 30 only
- Examples: `"0800"`, `"0830"`, `"1300"`, `"1330"`

**Difficulty: Hard (EXACT_TIME)**
- Hours: 0-23 (any hour)
- Minutes: 0-59 (any minute)
- Examples: `"0854"`, `"1322"`, `"2307"`

## Data Files Structure

**`src/data/hours.json`** - Hour building blocks (0-23)
**`src/data/minutes.json`** - Minute building blocks (0-59)

**Note:** Difficulty is NOT stored in JSON files - it's only a filter in the app settings.

## Example for Data Structure (Expressions)

```json
{
  //...
  "15": {
    "expressions": [
      {
        "hiragana": "じゅうごじ",
        "romaji": "juu-go ji"
      },
      {
        "hiragana": "さんじ",
        "romaji": "san ji"
      },
      {
        "hiragana": "ごごさんじ",
        "romaji": "gogo san ji"
      }
    ]
  }
  //
}
```

## Expression Combination Logic

Valid expressions for a timeId are generated by combining hour and minute expressions using a cartesian product.

### Process

1. Parse timeId into hour (first 2 digits) and minute (last 2 digits)
2. Retrieve all expressions for the hour from `hours.json`
3. Retrieve all expressions for the minute from `minutes.json`
4. Combine each hour expression with each minute expression. hiragana and romaji.

### Example

For timeId `"0105"`:
- Hour `"01"` has expressions: `["いちじ", "ごぜんいちじ"]`
- Minute `"05"` has expressions: `["ごふん"]`
- Result: `["いちじごふん", "ごぜんいちじごふん"]`

## Answer Validation Flow

The validation process matches user input against all valid expressions for the current timeId.

### Process

1. User submits input → `submitAnswer()` is called
2. `getValidExpressions(timeId)` generates all valid expressions using expression combination
3. `findMatchingExpression(userInput, validExpressions)` will check for a matching result
4. **On match** user was successful
5. **On no match**: user has failed

## AudioPlayer with Caching

The AudioPlayer uses a Map-based caching mechanism to store HTMLAudioElement instances for efficient audio playback.

### Caching Mechanism

- Audio elements are cached by URL
- When reusing cached audio, `currentTime` is reset to 0 before playback
- Prevents redundant audio element creation and decreases network traffic

### Audio Types

**Expression Audio (Voice Files)**
- Format: WebM files
- URL pattern: `sound/voice/{timeId}_{romaji}.webm`
- Example: `sound/voice/0105_ichi_ji_go-fun.webm`
- Romaji spaces are replaced with underscores in the filename

### Audio Generation

Audio files are generated using VoiceVox. See [src/scripts/README.md](src/scripts/README.md) for the complete audio generation process.

